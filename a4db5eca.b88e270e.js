(window.webpackJsonp=window.webpackJsonp||[]).push([[75],{133:function(e,t,r){"use strict";r.r(t),r.d(t,"frontMatter",(function(){return s})),r.d(t,"metadata",(function(){return o})),r.d(t,"rightToc",(function(){return l})),r.d(t,"default",(function(){return p}));var a=r(2),n=r(6),i=(r(0),r(173)),s={slug:"road-to-stryker-1-0",title:"Road to Stryker 1.0",author:"Nico Jansen",author_title:"Stryker Team",author_url:"https://github.com/nicojs",author_image_url:"https://avatars3.githubusercontent.com/u/1828233?s=400&u=fec18ad3776aaafec54c49bbd7173a841ae7ea59&v=4",tags:["stryker"]},o={permalink:"/blog/road-to-stryker-1-0",editUrl:"https://github.com/stryker-mutator/stryker-mutator.github.io/edit/develop/blog/2017-07-14-road-to-stryker-1-0.md",source:"@site/blog/2017-07-14-road-to-stryker-1-0.md",description:"Stryker is about two years old. During this time we achieved a lot. But it's far from finished. So, what's next? Let's take a glimpse in the future.",date:"2017-07-14T00:00:00.000Z",tags:[{label:"stryker",permalink:"/blog/tags/stryker"}],title:"Road to Stryker 1.0",readingTime:5.77,truncated:!0,prevItem:{title:"Stryker 0.8 release",permalink:"/blog/stryker-0-8-0"},nextItem:{title:"Stryker 0.6.4 released",permalink:"/blog/stryker-0-6-4"}},l=[{value:"Road to v1",id:"road-to-v1",children:[]},{value:"False assumption",id:"false-assumption",children:[]},{value:"First attempt",id:"first-attempt",children:[]},{value:"Open heart surgery",id:"open-heart-surgery",children:[{value:"Step 1: Initial test run",id:"step-1-initial-test-run",children:[]},{value:"Step 2: Mutation testing",id:"step-2-mutation-testing",children:[]}]},{value:"Plain JavaScript projects",id:"plain-javascript-projects",children:[]},{value:"Want to help?",id:"want-to-help",children:[]}],c={rightToc:l};function p(e){var t=e.components,s=Object(n.a)(e,["components"]);return Object(i.b)("wrapper",Object(a.a)({},c,s,{components:t,mdxType:"MDXLayout"}),Object(i.b)("p",null,"Stryker is about two years old. During this time we achieved a lot. But it's far from finished. So, what's next? Let's take a glimpse in the future."),Object(i.b)("p",null,"Some of Strykers achievements are:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"Stryker is the first functional mutation testing framework for JavaScript."),Object(i.b)("li",{parentName:"ul"},"Stryker is test framework and test runner agnostic."),Object(i.b)("li",{parentName:"ul"},"Stryker boosts performance by running tests in parallel."),Object(i.b)("li",{parentName:"ul"},"Stryker uses advance coverage analysis to do less work.")),Object(i.b)("p",null,"The way Stryker achieves all this, is using a plugin model. Want to use a different test runner?\nCreate a class that implements the ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/stryker-mutator/stryker/blob/master/packages/stryker-api/src/test_runner/TestRunner.ts"}),"TestRunner interface")," and you're done.\nHowever, Stryker does one assumption: your source code can be directly executed in your environment."),Object(i.b)("h2",{id:"road-to-v1"},"Road to v1"),Object(i.b)("p",null,"We're very happy with the results so far, but we're far from done. The JavaScript world is constantly evolving.\nA couple of examples of modern use cases are:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"A web project written in JSX / ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"https://facebook.github.io/react/"}),"React")),Object(i.b)("li",{parentName:"ul"},"A node project written in ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"https://www.typescriptlang.org/"}),"TypesScript")," and executed using ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"https://www.npmjs.com/package/ts-node"}),"ts-node")),Object(i.b)("li",{parentName:"ul"},"An Angular project generated with the ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"https://www.npmjs.com/package/@angular/cli"}),"angular cli")," using ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"https://webpack.js.org/"}),"webpack")," and ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"https://www.typescriptlang.org/"}),"TypeScript")),Object(i.b)("li",{parentName:"ul"},"A web project using ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"https://vuejs.org/"}),"VueJS")),Object(i.b)("li",{parentName:"ul"},"A web component written in HTML5 using ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"https://www.polymer-project.org"}),"Polymer")," and ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"https://webpack.js.org/"}),"webpack"))),Object(i.b)("p",null,"In order to stay relevant, these use cases need to be supported in a user friendly way.\nOnly then are we comfortable with tagging Stryker with a version ",Object(i.b)("em",{parentName:"p"},"1")," tag."),Object(i.b)("h2",{id:"false-assumption"},"False assumption"),Object(i.b)("p",null,"If you look at the modern use cases, they have something in common:\nyour code cannot be directly executed in your JavaScript environment. It's not even JavaScript in some cases.\nIt first needs to be compiled, transpiled and/or bundled, before it can be executed.\nFor the sake of this article, let's call this step ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://en.wikipedia.org/wiki/Source-to-source_compiler"}),"transpiling"),".\nThis makes the assumption that Stryker does a false one: ",Object(i.b)("strong",{parentName:"p"},"it should not assume the code you write is the code that gets executed"),"."),Object(i.b)("h2",{id:"first-attempt"},"First attempt"),Object(i.b)("p",null,"We've had a lot of discussion within the Stryker team on how to support these use cases.\nOne possibility is to first transpile your code before we run the normal Stryker process on it."),Object(i.b)("p",null,"In the end we decided against this approach, because it comes with a big downside: it will cause a lot of false positives."),Object(i.b)("p",null,"Let's take this piece of TypeScript code as an example:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),"const b = 42;\nconst a = `the answer is ${b}`;\n")),Object(i.b)("p",null,"This might transpile to:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"var b = 42;\nvar a = 'the answer is ' + b;\n")),Object(i.b)("p",null,"When Stryker comes along: it changes ",Object(i.b)("inlineCode",{parentName:"p"},"'the answer is ' + b")," to ",Object(i.b)("inlineCode",{parentName:"p"},"'the answer is ' - b"),".\nThis is a valid mutation for JavaScript (if you're curious: the answer is ",Object(i.b)("inlineCode",{parentName:"p"},"NaN"),").\nHowever, ",Object(i.b)("inlineCode",{parentName:"p"},"'the answer is ' - b")," is ",Object(i.b)("em",{parentName:"p"},"not a valid TypeScript expression"),". It results in the following compile error:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-bash"}),"The left-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.\n")),Object(i.b)("p",null,"This is why we refer to it as a false positive. This mutation shouldn't be tested, because it's a waste of resources and it impacts the mutation score. This is why we shouldn't blindly mutate transpiled code."),Object(i.b)("h2",{id:"open-heart-surgery"},"Open heart surgery"),Object(i.b)("p",null,"The only solution for supporting these use cases is to transpile the code after it has been mutated. This way, we can make sure only valid mutations are done to your code because\nwe ",Object(i.b)("em",{parentName:"p"},"teach")," Stryker which mutations are valid and which are invalid and we won't have to worry about code that gets generated during the transpilation."),Object(i.b)("p",null,"However, we don't want to just hard code it all in Stryker, because that would force a dependency on TypeScript, Babel, Webpack, etc.\nInstead the transpiling and mutating of the code will be the responsibility of a new plugin type.\nLet's call this the ",Object(i.b)("inlineCode",{parentName:"p"},"transpiler")," plugin. Examples of these plugins may be (in the future): ",Object(i.b)("inlineCode",{parentName:"p"},"stryker-typescript-transpiler"),", ",Object(i.b)("inlineCode",{parentName:"p"},"stryker-javascript-transpiler"),", ",Object(i.b)("inlineCode",{parentName:"p"},"stryker-babel-transpiler"),", ",Object(i.b)("inlineCode",{parentName:"p"},"stryker-webpack-transpiler")),Object(i.b)("p",null,"We've sketched the new workflow for the TypeScript use case on a whiteboard:"),Object(i.b)("p",null,Object(i.b)("img",{alt:"transpiler-plugin",src:r(238).default})),Object(i.b)("p",null,"Let's explain what happens in 2 steps:"),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},"Initial test run"),Object(i.b)("li",{parentName:"ol"},"Mutation testing")),Object(i.b)("h3",{id:"step-1-initial-test-run"},"Step 1: Initial test run"),Object(i.b)("p",null,"Starting from the top left: Stryker starts by reading your Stryker configuration file.\nAfter that, we read in the source files into memory. As you might have noticed, these will be the ",Object(i.b)("em",{parentName:"p"},"typescript files"),".\nNext up: it's the new ",Object(i.b)("inlineCode",{parentName:"p"},"stryker-typescript-transpiler")," plugin's time to shine. It will transpile the ",Object(i.b)("em",{parentName:"p"},".ts files into "),'.js files\nand it will use your "tsconfig.json" configuration for this. The JavaScript output of this process will\nbe written to disk by Stryker in something that we call a ',Object(i.b)("em",{parentName:"p"},"Sandbox"),". In this Sandbox, Stryker can\nstart the initial test run as usual."),Object(i.b)("p",null,"Why this complicated setup? After all, if we want to do an initial test run, we might as well just let your build process transpile the code\nand run the tests using your test runner. The answer is that we need a baseline of your tests ran by Stryker.\nIn the next step, Stryker will write mutations to different Sandboxes and run your tests.\nWe need a control step to make sure your tests pass under normal circumstances. Also: this is where\nwe measure your code coverage results for every test (if your test framework and test runner support it), which\nare used to speed up mutation testing."),Object(i.b)("h3",{id:"step-2-mutation-testing"},"Step 2: Mutation testing"),Object(i.b)("p",null,"After the initial test run completed successfully, we proceed with the actual mutation testing. The first step here\nis about figuring out how we can mutate your source code. This is again done by the ",Object(i.b)("inlineCode",{parentName:"p"},"stryker-typescript-transpiler")," plugin.\nIt will mutate the TypeScript specific ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://en.wikipedia.org/wiki/Abstract_syntax_tree"}),"abstract syntax tree"),", but ",Object(i.b)("em",{parentName:"p"},"only\nin valid ways"),". For example: it won't mutate ",Object(i.b)("inlineCode",{parentName:"p"},"'the answer is ' + 42")," into ",Object(i.b)("inlineCode",{parentName:"p"},"'the answer is ' - 42"),", but it might\nmutate it into ",Object(i.b)("inlineCode",{parentName:"p"},"'Stryker was here' + 42"),". The output of this process is a list of (in-memory) mutants."),Object(i.b)("p",null,"A mutant will have 2 parts: a TypeScript part and a JavaScript part. Stryker itself only cares about the\nJavaScript part, because that is the recipe to mutate the JavaScript code in the sandboxes.\nThis will allow Stryker to do mutation testing without needing to compile the code for each mutant, which would be disastrous for performance.\nThe TypeScript part of a mutant can be used to report the mutated code to the end user. So the mutants that will be reported\nin the exact code and language that the end user uses."),Object(i.b)("h2",{id:"plain-javascript-projects"},"Plain JavaScript projects"),Object(i.b)("p",null,"Back to plain JavaScript projects. What will change for them? The answer is: not much.\nWe'll basically move the current logic for mutating code to a new ",Object(i.b)("inlineCode",{parentName:"p"},"stryker-javascript-transpiler")," plugin.\nIt will be a pass-through transpiler, meaning that the code you write will be used directly.\nMutating of JavaScript code will move to this plugin as well."),Object(i.b)("h2",{id:"want-to-help"},"Want to help?"),Object(i.b)("p",null,"Want to help? Great! We're really looking for people interested in helping us reach our goal of supporting all JavaScript based projects!"))}p.isMDXComponent=!0},173:function(e,t,r){"use strict";r.d(t,"a",(function(){return u})),r.d(t,"b",(function(){return d}));var a=r(0),n=r.n(a);function i(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function s(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,a)}return r}function o(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?s(Object(r),!0).forEach((function(t){i(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):s(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function l(e,t){if(null==e)return{};var r,a,n=function(e,t){if(null==e)return{};var r,a,n={},i=Object.keys(e);for(a=0;a<i.length;a++)r=i[a],t.indexOf(r)>=0||(n[r]=e[r]);return n}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)r=i[a],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(n[r]=e[r])}return n}var c=n.a.createContext({}),p=function(e){var t=n.a.useContext(c),r=t;return e&&(r="function"==typeof e?e(t):o(o({},t),e)),r},u=function(e){var t=p(e.components);return n.a.createElement(c.Provider,{value:t},e.children)},b={inlineCode:"code",wrapper:function(e){var t=e.children;return n.a.createElement(n.a.Fragment,{},t)}},h=n.a.forwardRef((function(e,t){var r=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),u=p(r),h=a,d=u["".concat(s,".").concat(h)]||u[h]||b[h]||i;return r?n.a.createElement(d,o(o({ref:t},c),{},{components:r})):n.a.createElement(d,o({ref:t},c))}));function d(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=r.length,s=new Array(i);s[0]=h;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:a,s[1]=o;for(var c=2;c<i;c++)s[c]=r[c];return n.a.createElement.apply(null,s)}return n.a.createElement.apply(null,r)}h.displayName="MDXCreateElement"},238:function(e,t,r){"use strict";r.r(t),t.default=r.p+"assets/images/transpiler-plugin-122cea51d31d7eefb6326cb3367f022a.jpg"}}]);