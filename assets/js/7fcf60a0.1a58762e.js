(window.webpackJsonp=window.webpackJsonp||[]).push([[57],{132:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return i})),n.d(t,"metadata",(function(){return o})),n.d(t,"toc",(function(){return s})),n.d(t,"default",(function(){return c}));var a=n(3),r=(n(0),n(197));const i={title:"Mutant states and metrics",custom_edit_url:"https://github.com/stryker-mutator/mutation-testing-elements/edit/master/docs/mutant-states-and-metrics.md"},o={unversionedId:"mutation-testing-elements/mutant-states-and-metrics",id:"mutation-testing-elements/mutant-states-and-metrics",isDocsHomePage:!1,title:"Mutant states and metrics",description:"This page should shed some light on the different outcomes a mutant can have and the different metrics you'll find in any given mutation testing report.",source:"@site/docs/mutation-testing-elements/mutant-states-and-metrics.md",sourceDirName:"mutation-testing-elements",slug:"/mutation-testing-elements/mutant-states-and-metrics",permalink:"/docs/mutation-testing-elements/mutant-states-and-metrics",editUrl:"https://github.com/stryker-mutator/mutation-testing-elements/edit/master/docs/mutant-states-and-metrics.md",version:"current",frontMatter:{title:"Mutant states and metrics",custom_edit_url:"https://github.com/stryker-mutator/mutation-testing-elements/edit/master/docs/mutant-states-and-metrics.md"},sidebar:"docs",previous:{title:"Equivalent mutants",permalink:"/docs/mutation-testing-elements/equivalent-mutants"},next:{title:"Supported mutators",permalink:"/docs/mutation-testing-elements/supported-mutators"}},s=[{value:"Mutant states",id:"mutant-states",children:[]},{value:"Metrics",id:"metrics",children:[]},{value:"Test states and metrics",id:"test-states-and-metrics",children:[]}],l={toc:s};function c({components:e,...t}){return Object(r.b)("wrapper",Object(a.a)({},l,t,{components:e,mdxType:"MDXLayout"}),Object(r.b)("p",null,"This page should shed some light on the different outcomes a mutant can have and the different metrics you'll find in any given mutation testing report."),Object(r.b)("h2",{id:"mutant-states"},"Mutant states"),Object(r.b)("p",null,"A mutant can have one of the following states:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("strong",{parentName:"li"},"Killed"),"\nWhen at least one test failed while this mutant was active, the mutant is killed. This is what you want, good job!"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("strong",{parentName:"li"},"Survived"),"\nWhen all tests passed while this mutant was active, the mutant survived. You're missing a test for it."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("strong",{parentName:"li"},"No coverage"),"\nNo tests were executed for this mutant. It probably is located in a part of the code not hit by any of your tests. This means the mutant survived and you are missing a test case for it."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("strong",{parentName:"li"},"Timeout"),'\nThe running of tests with this mutant active resulted in a timeout.\nFor example, the mutant resulted in an infinite loop in your code.\nDon\'t spend too much attention to this mutant.\nIt is counted as "detected". The logic here is that if this mutant were to be injected in your code,\nyour CI build would detect it because the tests will never complete.'),Object(r.b)("li",{parentName:"ul"},Object(r.b)("strong",{parentName:"li"},"Runtime error"),"\nThe running of the tests resulted in an error (rather than a failed test).\nThis can happen when the testrunner fails. For example, when a testrunner throws an ",Object(r.b)("inlineCode",{parentName:"li"},"OutOfMemoryError")," or for dynamic languages where the mutant resulted in unparsable code.\nDon't spend too much attention looking at this mutant. It is not represented in your mutation score."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("strong",{parentName:"li"},"Compile error"),"\nThe mutant resulted in a compiler error.\nThis can happen in compiled languages.\nDon't spend too much attention looking at this mutant.\nIt is not represented in your mutation score."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("strong",{parentName:"li"},"Ignored"),"\nThe mutant was not tested because the config of the user asked for it to be ignored.\nThis will not count against your mutation score but will show up in reports.")),Object(r.b)("h2",{id:"metrics"},"Metrics"),Object(r.b)("p",null,"Based on these states, we can calculate the following metrics:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("strong",{parentName:"li"},"Detected")," ",Object(r.b)("inlineCode",{parentName:"li"},"killed + timeout"),Object(r.b)("br",{parentName:"li"}),"The number of mutants detected by your tests."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("strong",{parentName:"li"},"Undetected")," ",Object(r.b)("inlineCode",{parentName:"li"},"survived + no coverage"),Object(r.b)("br",{parentName:"li"}),"The number of mutants that are not detected by your tests."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("strong",{parentName:"li"},"Covered")," ",Object(r.b)("inlineCode",{parentName:"li"},"detected + survived"),Object(r.b)("br",{parentName:"li"}),"The number of mutants that your tests produce code coverage for."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("strong",{parentName:"li"},"Valid")," ",Object(r.b)("inlineCode",{parentName:"li"},"detected + undetected"),Object(r.b)("br",{parentName:"li"}),"The number of valid mutants. They didn't result in a compile error or runtime error."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("strong",{parentName:"li"},"Invalid")," ",Object(r.b)("inlineCode",{parentName:"li"},"runtime errors + compile errors"),Object(r.b)("br",{parentName:"li"}),"The number of invalid mutants. They couldn't be tested because they produce either a compile error or a runtime error."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("strong",{parentName:"li"},"Total mutants")," ",Object(r.b)("inlineCode",{parentName:"li"},"valid + invalid + ignored"),Object(r.b)("br",{parentName:"li"}),"All mutants."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("strong",{parentName:"li"},"Mutation score")," ",Object(r.b)("inlineCode",{parentName:"li"},"detected / valid * 100"),Object(r.b)("br",{parentName:"li"}),"The total percentage of mutants that were killed."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("strong",{parentName:"li"},"Mutation score based on covered code")," ",Object(r.b)("inlineCode",{parentName:"li"},"detected / covered * 100"),Object(r.b)("br",{parentName:"li"}),"The total percentage of mutants that were killed based on the code coverage results.")),Object(r.b)("h2",{id:"test-states-and-metrics"},"Test states and metrics"),Object(r.b)("p",null,"A ",Object(r.b)("em",{parentName:"p"},"test")," can also have state with regards to mutation testing."),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("strong",{parentName:"li"},"Killing"),"\nThe test is killing at least one mutant. This is what you want."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("strong",{parentName:"li"},"Not killing"),"\nThe test is covering mutants, but not killing any of them. The coverage information should be available per test to provide this test state."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("strong",{parentName:"li"},"Not covering"),"\nThe test is not even covering any mutants (and thus not killing any of them)."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("strong",{parentName:"li"},"Total")," ",Object(r.b)("inlineCode",{parentName:"li"},"not covering + not killing + killing"),"\nTotal number of tests.")))}c.isMDXComponent=!0},197:function(e,t,n){"use strict";n.d(t,"a",(function(){return m})),n.d(t,"b",(function(){return p}));var a=n(0),r=n.n(a);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=r.a.createContext({}),u=function(e){var t=r.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},m=function(e){var t=u(e.components);return r.a.createElement(c.Provider,{value:t},e.children)},b={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},d=r.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,o=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),m=u(n),d=a,p=m["".concat(o,".").concat(d)]||m[d]||b[d]||i;return n?r.a.createElement(p,s(s({ref:t},c),{},{components:n})):r.a.createElement(p,s({ref:t},c))}));function p(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,o[1]=s;for(var c=2;c<i;c++)o[c]=n[c];return r.a.createElement.apply(null,o)}return r.a.createElement.apply(null,n)}d.displayName="MDXCreateElement"}}]);